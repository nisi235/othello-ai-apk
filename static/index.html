<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ã‚ªã‚»ãƒ­AIå¯¾å¿œ</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #0b5500;
      font-family: "Meiryo UI", sans-serif;
      color: white;
      user-select: none;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(8, 50px);
      grid-template-rows: repeat(8, 50px);
      gap: 1px;
      background-color: black;
      padding: 5px;
      border-radius: 8px;
      box-shadow: 0 0 10px #004400;
      margin-top: 10px;
    }
    .cell {
      width: 50px;
      height: 50px;
      background-color: #0a7f0a;
      border-radius: 5px;
      cursor: pointer;
      position: relative;
      box-sizing: border-box;
      border: 1px solid #004400;
      transition: background-color 0.2s ease;
    }
    .cell:hover {
      background-color: #0f9f0f;
    }
    .cell.black::after,
    .cell.white::after {
      content: "";
      position: absolute;
      top: 7px;
      left: 7px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      box-shadow: 0 0 5px rgba(0,0,0,0.5);
    }
    .cell.black::after {
      background-color: black;
    }
    .cell.white::after {
      background-color: white;
      border: 1px solid #000;
    }

    #controls {
      margin-top: 20px;
      width: 420px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #aiSelect {
      font-size: 16px;
      padding: 4px 8px;
      border-radius: 4px;
    }

    #currentAI {
      font-size: 14px;
      background: rgba(0,0,0,0.3);
      padding: 6px 10px;
      border-radius: 4px;
      min-width: 140px;
      text-align: center;
    }

    #passButton {
      margin-top: 15px;
      padding: 8px 20px;
      font-size: 16px;
      border-radius: 6px;
      background-color: #004400;
      color: white;
      border: none;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.3s ease;
    }
    #passButton:hover:not(:disabled) {
      background-color: #006600;
    }
    #passButton:disabled {
      background-color: #003300;
      cursor: default;
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <h1>ã‚ªã‚»ãƒ­AI å¯¾æˆ¦</h1>

  <div id="board"></div>

  <div id="controls">
    <label for="aiSelect">AIãƒ¢ãƒ‡ãƒ«é¸æŠ:</label>
    <select id="aiSelect">
      <option value="ai1">AI ãƒ¬ãƒ™ãƒ« 1</option>
      <option value="ai2">AI ãƒ¬ãƒ™ãƒ« 2</option>
      <option value="ai3">AI ãƒ¬ãƒ™ãƒ« 3</option>
      <option value="ai4">AI ãƒ¬ãƒ™ãƒ« 4</option>
      <option value="ai5">AI ãƒ¬ãƒ™ãƒ« 5</option>
    </select>

    <div id="currentAI">ç¾åœ¨ã®AI: AI ãƒ¬ãƒ™ãƒ« 1</div>
  </div>

  <button id="passButton" disabled>ãƒ‘ã‚¹</button>

  <script>
    const BOARD_SIZE = 8;
    let board = Array.from({length: BOARD_SIZE}, () => Array(BOARD_SIZE).fill(0));
    let currentPlayer = 1; // 1: é»’(ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼), -1: ç™½(AI)
    let aiSelect = document.getElementById("aiSelect");
    let currentAILabel = document.getElementById("currentAI");
    let passButton = document.getElementById("passButton");

    let gameOver = false;

    let selectedAIKey = aiSelect.value;

    aiSelect.addEventListener("change", () => {
      selectedAIKey = aiSelect.value;
      currentAILabel.textContent = `ç¾åœ¨ã®AI: ${aiSelect.options[aiSelect.selectedIndex].text}`;
      resetGame();
    });

    passButton.addEventListener("click", () => {
      if (gameOver) return;
      if (currentPlayer !== 1) return; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³ã®ã¿
      if (!hasAnyValidMove(currentPlayer)) {
        alert("ãƒ‘ã‚¹ã—ã¾ã—ãŸã€‚AIã®æ‰‹ç•ªã§ã™ã€‚");
        currentPlayer = -currentPlayer;
        updatePassButton();
        renderBoard();
        setTimeout(aiMove, 500);
      } else {
        alert("ã¾ã ç½®ã‘ã‚‹å ´æ‰€ãŒã‚ã‚Šã¾ã™ã€‚ãƒ‘ã‚¹ã§ãã¾ã›ã‚“ã€‚");
      }
    });

    function resetGame() {
      gameOver = false;
      currentPlayer = 1;
      initializeBoard();
      renderBoard();
      updatePassButton();
    }

    function initializeBoard() {
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          board[y][x] = 0;
        }
      }
      board[3][3] = -1;
      board[3][4] = 1;
      board[4][3] = 1;
      board[4][4] = -1;
    }

    function renderBoard() {
      const boardDiv = document.getElementById("board");
      boardDiv.innerHTML = "";

      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");

          if (board[y][x] === 1) cell.classList.add("black");
          else if (board[y][x] === -1) cell.classList.add("white");

          cell.dataset.x = x;
          cell.dataset.y = y;

          // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã‚„AIã‚¿ãƒ¼ãƒ³ã¯ã‚¯ãƒªãƒƒã‚¯ç¦æ­¢
          if (!gameOver && currentPlayer === 1) {
            cell.addEventListener("click", () => {
              if (placePiece(x, y, currentPlayer)) {
                currentPlayer = -currentPlayer;
                renderBoard();
                updatePassButton();
                setTimeout(aiMove, 500);
              } else {
                alert("ãã“ã«ã¯ç½®ã‘ã¾ã›ã‚“ã€‚");
              }
            });
          }

          boardDiv.appendChild(cell);
        }
      }
    }

    function canPlace(x, y, color) {
      if (board[y][x] !== 0) return false;
      const directions = [
        [1,0], [-1,0], [0,1], [0,-1],
        [1,1], [-1,-1], [1,-1], [-1,1]
      ];
      for (const [dx, dy] of directions) {
        let nx = x + dx;
        let ny = y + dy;
        let foundOpponent = false;
        while (nx >= 0 && ny >= 0 && nx < BOARD_SIZE && ny < BOARD_SIZE) {
          if (board[ny][nx] === -color) {
            foundOpponent = true;
            nx += dx;
            ny += dy;
          } else {
            break;
          }
        }
        if (foundOpponent && nx >= 0 && ny >= 0 && nx < BOARD_SIZE && ny < BOARD_SIZE) {
          if (board[ny][nx] === color) return true;
        }
      }
      return false;
    }

    function hasAnyValidMove(color) {
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (canPlace(x, y, color)) return true;
        }
      }
      return false;
    }

    function placePiece(x, y, color) {
      if (!canPlace(x, y, color)) return false;
      board[y][x] = color;
      const directions = [
        [1,0], [-1,0], [0,1], [0,-1],
        [1,1], [-1,-1], [1,-1], [-1,1]
      ];
      for (const [dx, dy] of directions) {
        let nx = x + dx;
        let ny = y + dy;
        let toFlip = [];
        while (nx >= 0 && ny >= 0 && nx < BOARD_SIZE && ny < BOARD_SIZE && board[ny][nx] === -color) {
          toFlip.push([nx, ny]);
          nx += dx;
          ny += dy;
        }
        if (nx >= 0 && ny >= 0 && nx < BOARD_SIZE && ny < BOARD_SIZE && board[ny][nx] === color) {
          for (const [fx, fy] of toFlip) {
            board[fy][fx] = color;
          }
        }
      }
      return true;
    }

    async function aiMove() {
      if (gameOver) return;

      if (!hasAnyValidMove(currentPlayer)) {
        alert("AIã¯ç½®ã‘ã‚‹å ´æ‰€ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã‚ãªãŸã®æ‰‹ç•ªã§ã™ã€‚");
        currentPlayer = -currentPlayer;
        updatePassButton();
        renderBoard();
        checkGameEnd();
        return;
      }

      try {
        const res = await fetch("https://othello-ai-apk.onrender.com/predict", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            model_key: selectedAIKey,
            board: board
          })
        });

        if (!res.ok) {
          alert("AIã®å¿œç­”ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
          return;
        }

        const data = await res.json();
        const { x, y } = data;

        if (!canPlace(x, y, currentPlayer)) {
          alert("AIãŒä¸æ­£ãªæ‰‹ã‚’è¿”ã—ã¾ã—ãŸã€‚");
          return;
        }

        placePiece(x, y, currentPlayer);
        currentPlayer = -currentPlayer;
        renderBoard();
        updatePassButton();

        checkGameEnd();

      } catch (e) {
        alert("é€šä¿¡ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + e.message);
      }
    }

    function countPieces() {
      let black = 0, white = 0;
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] === 1) black++;
          else if (board[y][x] === -1) white++;
        }
      }
      return { black, white };
    }

    function checkGameEnd() {
      // ã©ã¡ã‚‰ã‚‚ç½®ã‘ãªã„ãªã‚‰ã‚²ãƒ¼ãƒ çµ‚äº†
      if (!hasAnyValidMove(1) && !hasAnyValidMove(-1)) {
        gameOver = true;
        passButton.disabled = true;

        const { black, white } = countPieces();
        let msg = `ã‚²ãƒ¼ãƒ çµ‚äº†ï¼\né»’(ã‚ãªãŸ): ${black} çŸ³\nç™½(AI): ${white} çŸ³\n\n`;
        if (black > white) msg += "ã‚ãªãŸã®å‹ã¡ã§ã™ï¼ ğŸ‰";
        else if (white > black) msg += "AIã®å‹ã¡ã§ã™...";
        else msg += "å¼•ãåˆ†ã‘ã§ã™ã€‚";

        alert(msg);
      }
    }

    function updatePassButton() {
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹ç•ªã‹ã¤ç½®ã‘ã‚‹å ´æ‰€ãŒãªã„å ´åˆã®ã¿æœ‰åŠ¹
      passButton.disabled = !(currentPlayer === 1 && !hasAnyValidMove(1) && !gameOver);
    }

    // åˆæœŸåŒ–
    resetGame();

  </script>
</body>
</html>
